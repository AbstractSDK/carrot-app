use cosmwasm_schema::{cw_serde, QueryResponses};
use cosmwasm_std::{Coin, Decimal, Uint128, Uint64};
use cw_asset::AssetBase;

use crate::{
    contract::App,
    state::{AutocompoundRewardsConfig, Position},
};

// This is used for type safety and re-exporting the contract endpoint structs.
abstract_app::app_msg_types!(App, AppExecuteMsg, AppQueryMsg);

/// Carrot app instantiate message
#[cosmwasm_schema::cw_serde]
pub struct AppInstantiateMsg {
    /// Id of the pool used to get rewards
    pub pool_id: u64,
    /// Seconds to wait before autocompound is incentivized.
    pub autocompound_cooldown_seconds: Uint64,
    /// Configuration of rewards to the address who helped to execute autocompound
    pub autocompound_rewards_config: AutocompoundRewardsConfig,
    /// Create position with instantiation.
    /// Will not create position if omitted
    pub create_position: Option<CreatePositionMessage>,
}

#[cosmwasm_schema::cw_serde]
pub struct CreatePositionMessage {
    pub lower_tick: i64,
    pub upper_tick: i64,
    // Funds to use to deposit on the account
    pub funds: Vec<Coin>,
    /// The two next fields indicate the token0/token1 ratio we want to deposit inside the current ticks
    pub asset0: Coin,
    pub asset1: Coin,
    // Slippage
    pub max_spread: Option<Decimal>,
    pub belief_price0: Option<Decimal>,
    pub belief_price1: Option<Decimal>,
}

/// Carrot app execute messages
#[cosmwasm_schema::cw_serde]
#[cfg_attr(feature = "interface", derive(cw_orch::ExecuteFns))]
#[cfg_attr(feature = "interface", impl_into(ExecuteMsg))]
pub enum AppExecuteMsg {
    /// Create a position for a supercharged liquidity pool
    /// Example: A user wants to create a liquidity position with 1000USDC and 1000USDT within a specifc range
    /// This method is Permissioned
    CreatePosition(CreatePositionMessage),
    /// This adds funds to an already existing position
    /// Example: A user who has already a position with 1000USDC and 1000USDT would like to add 200USDC and 200USDT
    /// This method is Permissioned
    Deposit {
        funds: Vec<Coin>,
        max_spread: Option<Decimal>,
        belief_price0: Option<Decimal>,
        belief_price1: Option<Decimal>,
    },
    /// Withdraw a share from the LP position
    /// Example: A user who has already a position with 1000USDC and 1000USDT would like to withdraw 200USDC and 200USDT
    /// Note: This will not claim the rewards earned from the swapping fees generated by the position
    /// This method is Permissioned
    Withdraw { amount: Uint128 },
    /// Withdraw all the amount in the position
    /// Example: A user who has already a position with 1000USDC and 1000USDT would like to withdraw all the funds
    /// Note: This will claim the rewards earned from the swapping fees generated by the position
    /// This function is Permissioned
    WithdrawAll {},
    /// For a user who has already created a position, this function does two steps:
    /// 1 - claims all the rewards generated by the position
    /// 2 - adds/deposits the claimed spread rewards to that same position
    /// This is meant to be called by a carrot-app bot, that receives rewards upon autocompounding.
    /// Executor will receive rewards specified in [`CompoundStatusResponse::autocompound_reward`].
    /// Rewards won't be sent in case [`CompoundStatus`] is not ready or executor is admin of the contract.
    /// This function is not Permissioned
    Autocompound {},
}

/// Carrot app query messages
#[cosmwasm_schema::cw_serde]
#[cfg_attr(feature = "interface", derive(cw_orch::QueryFns))]
#[cfg_attr(feature = "interface", impl_into(QueryMsg))]
#[derive(QueryResponses)]
pub enum AppQueryMsg {
    #[returns(crate::state::Config)]
    Config {},
    #[returns(AssetsBalanceResponse)]
    Balance {},
    #[returns(PositionResponse)]
    Position {},
    /// Get the status of the compounding logic of the application and pool rewards
    /// Returns [`CompoundStatusResponse`]
    #[returns(CompoundStatusResponse)]
    CompoundStatus {},
}

#[cosmwasm_schema::cw_serde]
pub struct AppMigrateMsg {}

#[cosmwasm_schema::cw_serde]
pub struct BalanceResponse {
    pub balance: Vec<Coin>,
}

#[cw_serde]
pub struct AssetsBalanceResponse {
    pub balances: Vec<Coin>,
    pub liquidity: String,
}

#[cw_serde]
pub struct PositionResponse {
    pub position: Option<Position>,
}

#[cw_serde]
pub struct CompoundStatusResponse {
    pub status: CompoundStatus,
    pub autocompound_reward: AssetBase<String>,
    /// Wether user have enough balance to reward or can swap to get enough
    pub autocompound_reward_available: bool,
    pub pool_rewards: Vec<Coin>,
}

#[cw_serde]
/// Wether contract is ready for the compound
pub enum CompoundStatus {
    /// Contract is ready for the compound
    Ready {},
    /// How much seconds left for the next compound
    Cooldown(Uint64),
    /// No open position right now
    NoPosition {},
}

impl CompoundStatus {
    pub fn is_ready(&self) -> bool {
        matches!(self, Self::Ready {})
    }
}
